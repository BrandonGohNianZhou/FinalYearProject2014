//--------------------------//
// Stage.cs					//
// ステージクラス			//
//	Stage Class
// 制作日:2013/10/03			//
// 制作者:Kouno Shin			//
//--------------------------//

//----------------------//
//----名前空間の省略-----//
//	Abbreviation of the name space
//----------------------//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using XNAFrameWork;
using Microsoft.Xna.Framework.Input;

namespace XNAFrameWork
{
	class Stage
	{
		#region Constant declaration

		const int MAX_STAGE_NUM = 13;		// Maximum number of stages
		const int STAGE_LENGTH = 1060;		// Length per stage

		#endregion

		#region Field

		// Position of the player
		Vector3 playerPos;

		// Stage data
        StageData[] stageData = new StageData[MAX_STAGE_NUM];

		// Stage of beginning
		StageData startStage;
		// Stage at the end
		StageData endStage;

		// Number of stages which cleared
		int clearStageCount;

		// Score
		public Score score{get;set;}

		// Whether damaged
		static public bool damegeEffect = false;
		// Count the damage effect is over
		static public int damegeCount = 0;

		#endregion

		#region Constructor

		// I get the position of the player
		public Stage(Vector3 playerPos)
		{
			// Initialize the position of the player
			this.playerPos = playerPos;

			// Initialization of the number of stages which cleared
			this.clearStageCount = 0;

			// Initialization stage of data
			this.InitStage();

			// Initialization of the score
			this.score = new Score();
		}

		#endregion

        #region FEEDBACK

        Feedback FB_effects = new Feedback(0);

        #endregion

		#region Function

		//------------------------------//
		// 関数名	InitStage			//
		//	Function name InitStage
		// 機能		ステージの初期化		//
		//	Initialization function of stage
		// 引数		なし					//
		//	No argument
		// 戻り値	なし					//
		//	No return value
		//------------------------------//
		private void InitStage()
		{
			//----Initialization stage of start and end----//

			// Instantiation
			this.startStage = new StageData(7);
			this.endStage	= new StageData(8);

			// Settings for each value
			this.startStage.Scale = Vector3.One * 4.2f;
			this.startStage.Rotation = Vector3.Zero;
			this.endStage.Scale = Vector3.One * 4.2f;
			this.endStage.Rotation = Vector3.Zero;

			// Whether to draw
			this.startStage.isPlayAnimation = true;
			this.endStage.isPlayAnimation = false;

			// Position setting
			this.startStage.PosZ = 505.0f;  // 500

			// I keep updating only one frame
			this.startStage.OnlyOneFrameUpdate();
			this.endStage.OnlyOneFrameUpdate();

			//----Initialization of each stage data----//
			for (int i = 0; i < MAX_STAGE_NUM; i++)
			{
                int temp = MyMathHelper.rand.Next(0, 7);

                //temp = 4;

				// Instance of the data stage (stages 0-6 is generated by random)
                this.stageData[i] = new StageData(temp);

				// Settings for each value
                // activation
                this.stageData[i].active = false;
				// Scale
				this.stageData[i].Scale = Vector3.One * 4.2f;
				// No rotation
				this.stageData[i].Rotation = Vector3.Zero;
			}

			// Positioning of the stage
			// Hard-coded only the very first stage
			this.stageData[0].PosZ = -560.0f;
			// Setting the stage for other
			for (int i = 0; i < stageData.Length; i++)
			{
				// I open stage one minute the position of all stages
				if (i < stageData.Length - 1)
				{
                    stageData[i + 1].PosZ = stageData[i].PosZ - STAGE_LENGTH - 5.0f;
				}
				// Update only one frame
				stageData[i].OnlyOneFrameUpdate();
			}

            // set stage active
            this.SetStageActive();

            // init feedback
            InitFeedback();
		}

		//------------------------------------------//
		// 関数名	Update							//
		//	Function Update
		// 機能		プレイヤーの今の位置によって		//
		//	Depending on the position of the now function of Player
		//			ステージを更新する				//
		//	Update the stage
		// 引数		なし								//
		//	No argument
		// 戻り値	なし								//
		//	No return value
		//------------------------------------------//
        public bool Update(GameTime gameTime, Vector3 playerPos, bool playerInvi, Vector3 playerVel, bool playerDuck)
		{
            // bool check player hit obstacle
            bool tempcheck = false;

			// Update the position of the player...refresh player position
			this.playerPos = playerPos;

            // set stage active
            this.SetStageActive();

			if (playerPos.Z < 300.0)
			{
				//  Once a player has exceeded the boundaries of the stage
				if (this.CalcNextAnimationStage().PosZ + STAGE_LENGTH * 0.5f
					 < playerPos.Z)
				{
					// Ready to start the animation
					CalcNextAnimationStage().isPlayAnimation = true;
				}
			}

			// I repeat stage minutes...repeat something about the stage
			for (int i = 0; i < stageData.Length; i++)
			{
				// If ready to start the animation if
				if (stageData[i].isPlayAnimation)
				{
					// I let the animation
					stageData[i].Update(gameTime);
				}

                // skip collision if player is invincible
                if (playerInvi || !stageData[i].active) continue;

				// Hit determination process of the stage and players...if the obstacle hits the player!
                if (stageData[i].Hit(this.playerPos, playerDuck))
                {
					// Set the time the damage effect is out
                    damegeCount = 20;

                    //if (!FB_effects.animate2)
                    //{
                    // reset speed
                    Player.extraspeed = 0.0f;

                    // bad effect and reduce life
                    FB_effects.Reset2((int)EffectType.BOO);
                    LifePoint.LP -= 1;
                    this.score.combo = 1;
                    tempcheck = true;
                    //}
                }
			}

			// If you take damage if...if receive damage
			if (damegeCount > 0)
			{
				// Damage processing
				damegeEffect = true;
				// Subtract the damage count
				damegeCount--;
			}
			else
			{
				// Do not damage processing
				damegeEffect = false;
			}

			// Placement of new processing stage....put a new stage
		//	this.PutNewStage();

			// I make animation start and end.....animate the stage
			if (startStage.isPlayAnimation)
			{
				startStage.Update(gameTime);
			}
			if (endStage.isPlayAnimation
				&& playerPos.Z < -13000)
			{
				endStage.Update(gameTime);
			}

            // check player passes obstacle
            for (int i = 0; i < stageData.Length; i++)
            {
                if (!stageData[i].active) continue;
                if (stageData[i].CheckSafePass())
                {
                    // increase speed
                    Player.extraspeed -= 0.15f;

                    // good effect and add score
                    if (Score.acc_level == 2)
                    {
                        FB_effects.Reset2((int)EffectType.PERFECT);
                    }
                    else if (Score.acc_level == 1)
                    {
                        FB_effects.Reset2((int)EffectType.GOOD);
                    }
                    this.score.AddScore();
                }
            }

            // update feedback effect
            UpdateFeedback(gameTime);

            // update score
            this.score.Update(playerVel);

            return tempcheck;
		}

        #region FEEDBACK_FUNCTIONS
        
        // init feedback
        public void InitFeedback()
        {
            FB_effects = new Feedback(0);
        }

        // update feedback
        public void UpdateFeedback(GameTime gameTime)
        {
            FB_effects.Update(gameTime);
        }

        // draw feedback
        public void DrawFeedback()
        {
            FB_effects.Draw2D();
        }

        public void Draw2D(bool cleargame)
        {
            if (cleargame) return;

            //Game1.debugText.Printf("s0:" + this.stageData[0].PosZ, new Vector2(250, 250));
            //Game1.debugText.Printf("s1:" + this.stageData[1].PosZ, new Vector2(250, 280));
            //Game1.debugText.Printf("s2:" + this.stageData[2].PosZ, new Vector2(250, 310));

            // draw feedback effect
            DrawFeedback();

            // draw score
            this.score.Draw2D();
            //Game1.debugText.Printf("SCORE", new Vector2(320, 0));
            //Game1.debugText.Printf(score.score.ToString(), new Vector2(350, 30));
        }

        #endregion

        //----------------------------------//
		// 関数名	Draw					//
		//	Function Draw
		// 機能		ステージの描画処理		//
		//	Drawing stage process of the function
		// 引数		なし						//
		//	No argument
		// 戻り値	なし						//
		//	No return value
		//----------------------------------//
		public void Draw3D()
		{
            //for (int i = 0; i < stageData.Length; i++)
            //{
            //    // Drawing
            //    stageData[i].Draw();
            //}

            for (int i = stageData.Length - 1; i >= 0; --i)
			{
                // if stage is active
                if (stageData[i].active)
                {
                    // Drawing
                    stageData[i].Draw();
                }
			}

			// Drawing of the start and end
			startStage.Draw();
            if (endStage.isPlayAnimation)
            {
                endStage.Draw();
            }
        }

        // set stage active
        void SetStageActive()
        {
            // bool to get the current stage number player is in
            bool FoundCurrentStage = false;
            int CurrentStageNumber = 0;

            // go throught all the stage
            for (int i = 0; i < MAX_STAGE_NUM; ++i)
            {
                // set active false
                stageData[i].active = false;
                 
                // if player passed the stage
                if (playerPos.Z < stageData[i].PosZ - STAGE_LENGTH * 0.5f - 250.0f)
                {
                    // do nothing here
                }
                // if player haven pass this stage
                else
                {
                    // set current stage number if not setted yet
                    if (!FoundCurrentStage)
                    {
                        CurrentStageNumber = i;
                        FoundCurrentStage = true;
                    }
                }
            }

            // set active for current stage player in and 2 stage infront
            // check out of array
            if (CurrentStageNumber < MAX_STAGE_NUM)
            {
                stageData[CurrentStageNumber].active = true;
            }
            // check out of array
            if (CurrentStageNumber + 1 < MAX_STAGE_NUM) 
            {
                stageData[CurrentStageNumber + 1].active = true;
            }
            // check out of array
            if (CurrentStageNumber + 2 < MAX_STAGE_NUM)
            {
                stageData[CurrentStageNumber + 2].active = true;
            }
            // else player reach the 2nd last stage
            else 
            {
                // show end stage
                if (!endStage.isPlayAnimation)
                {
                    endStage.isPlayAnimation = true;
                    endStage.PosZ = stageData[CurrentStageNumber+1].PosZ - STAGE_LENGTH;
                }	
            }
        }

		//--------------------------------------//
		// 関数名	PutNewStage					//
		//	Function name PutNewStage
		// 機能		新しいステージの構築			//
		//	Build a new stage function
		// 引数		なし							//
		//	No argument
		// 戻り値	なし							//
		//	No return value
		//--------------------------------------//
		private void PutNewStage()
		{
			// Variable to the repeated drawing
			float distance = 0.0f;			// Save for the distance of the stage and players
			int stageNum = 0;				// Element number storage of stage who is farthest
			float farPosZ = 0.0f;			// Save for the farthest distance

			// I examine the stage that are farthest (furtest infront of player)
			for (int i = 0; i < stageData.Length; i++)
			{
				// Stage of this time if it has more distant than the previous stage if
				if (distance < playerPos.Z - stageData[i].PosZ)
				{
					// Save how much the away
					distance = playerPos.Z - stageData[i].PosZ;
					// Which stage or save was away
					stageNum = i;
				}
				// I remember the location of the plate was away the most
				farPosZ = stageData[stageNum].PosZ;
			}

			// If you still can be arranged if
			if (clearStageCount < 10)
			{
				// Set in the farthest
				for (int i = 0; i < stageData.Length; i++)
				{
					// Stage When you come to the front of the player if
					// Initialize the wall
					if (stageData[i].PosZ - 600.0 > playerPos.Z)
                    {
                        int temp = MyMathHelper.rand.Next(0, 7);

                        //temp = 4;

						// The random generate a new stage
                        stageData[i] = new StageData(temp);

						// Set the scale
						stageData[i].Scale = Vector3.One * 4.2f;
						// Set in the farthest position from the player stage
                        stageData[i].PosZ = farPosZ - STAGE_LENGTH;
						// I keep updating only one frame
						stageData[i].OnlyOneFrameUpdate();
						// Count the number of stages which cleared
						this.clearStageCount++;
					}
				}
			}
			// If state it can not be placed more
			else
			{
				if (!endStage.isPlayAnimation)
				{
					endStage.isPlayAnimation = true;
					endStage.PosZ = farPosZ - STAGE_LENGTH;
					endStage.Scale = Vector3.One * 4.2f;
				}	
			}
		}

		//----------------------------------------------------------//
		// 関数名	CalcNextAnimationStage							//
		//	Function name CalcNextAnimationStage
		// 機能		次アニメーションが始まるステージデータを算出		//
		//	To calculate the stage data following features animation starts
		// 引数		なし												//
		//	No argument
		// 戻り値	なし												//
		//	No return value
		//----------------------------------------------------------//
		private StageData CalcNextAnimationStage()
		{
			// Stage in the front of the player
			int frontOfPlayerStageNumber = -1;

			// Variable to the repeated drawing
			float distance = -1000000.0f;		// Save for the distance of the stage and players
			int nearStageNum = 0;				// Element number storage of stage who is in closest position

			//// To calculate the stage in the back from players
            //for (int i = 0; i < stageData.Length; i++)
            //{
			//    // If there is a stage in the front of the player if
            //    if (playerPos.Z < stageData[i].PosZ)
            //    {
			//        // I remember the stage number
            //        frontOfPlayerStageNumber = i;
            //    }
				
            //}
			// I examine the stage who is in closest position
			for (int i = 0; i < stageData.Length; i++)
			{
				// If there is a stage in the front of the player if
                if (playerPos.Z < stageData[i].PosZ)
                {
					// I remember the stage number
                    frontOfPlayerStageNumber = i;
                }

				// To calculate the stage close to the No. 1 player from the stage left
				if (i == frontOfPlayerStageNumber)
				{
					// Stage at the near side skip
					continue;
				}

				// Stage of this time is closer than the previous stage if
				if (distance < playerPos.Z + stageData[i].PosZ)
				{
					// Save how close
					distance = playerPos.Z + stageData[i].PosZ;
					// Which stage or save was close
					nearStageNum = i;
				}
			}
			// I return to the stage
			return stageData[nearStageNum];
		}

		#endregion
	}
}
